## 线程简介
### 程序
程序是 指令和数据 的集合，其本身没有任何运行的含义，是一个静态的概念。
### 进程
进程：在操作系统中，每一个独立的程序都可以称之为一个进程————正在运行的程序（进程就是程序执行的过程，它是一个动态的概念），进程是系统分配资源的单位
### 线程
* 每个运行的程序都是一个进程，在一个进程中还可以有多个执行单元同时运行，这些运执行单元可以看作程序执行的一 条路径，被称为线程。
* 线程是CPU调度和执行的单位。
* 操作系统中的每一个进程中都至少存在一个线程。
* 当一个Java程序启动时就会产生一个进程， 该进程会默认创建一个线程， 在这个线程上会运行main ()方法中的代码。
### 多线程
* 在一个进程中，同时运行了多个线程，用来完成不同的工作，称之为多线程
* 多个线程之间交替占用CPU资源，而不是真正的并行执行
* 好处：
  * 充分利用CPU资源
  * 简化编程模型
  * 带来良好的用户体验
* 很多多线程是模拟出来的，真正的多线程是指多个CPU同时运行。如果是模拟出来的多线程，即在一个cpu的情况下，在同一个时间点，cpu只能执行一个代码，因为切换的很快，所以就有同时执行的错觉
### 普通方法调用和多线程调用
![普通调用](https://img-blog.csdnimg.cn/e7fbc72bad9245bebe1ba9f133fc4b55.png)
![多线程调用](https://img-blog.csdnimg.cn/639bf4e5d2f243c5ab3afd478825c3f8.png)
核心概念：
* 线程就是独立的执行路径。
* 在程序运行时，即使没有自己创建线程，后台也会有多个线程，如主线程，gc线程。
* main()称之为主线程，为系统的入口，用于执行整个程序。
* 在一个进程中，如果开辟了多个线程，线程的运行由调度器安排调度，调度器是与操作系统紧密相关的，先后顺序是不能人为的干预的。
* 对同一份资源操作时，会存在资源抢夺的问题，需要加入并发控制。
* 线程会带来额外的开销，如cpu调度时间，并发控制开销。
* 每个线程在自己的工作内存交互，内存控制不当会造成数据不一致

例子：
-> soutThreadName.java  <-

---

## 线程创建
### 继承Thread类
将一个类声明为Thread的子类。这个子类应该重写run类的方法Thread。然后可以分配并启动子类的实例。
可以分为三步：
* 自定义线程类继承Thread类。
* 重写run（）方法，编写线程执行体。
* 创建线程对象，调用start（）方法启动线程。
  

例子：
  -> ThreadCreateByExtendsThread .java  <-

### 实现Runnable接口
创建一个线程是声明实现类Runnable接口。那个类然后重写run类的方法。然后可以分配类的实例，在创建的时候作为参数传递，并启动。
可以分为三步：
* 定义MyRunnable类实现Runnable接口
* 实现run()方法，编写线程执行体
* 创建线程对象，调用start()方法启动线程

例子：
-> ThreadCreateByImplementRunnable .java  <-

总结：
* 继承Thread类
  * 子类继承Thread类具有多线程能力
  * 启动线程：子类对象.start（）
  * 不建议使用：避免OOP单继承局限性
* 实现Runnable接口
  * 实现接口Runnable具有多线程能力
  * 启动线程：传入目标对象+Thread对象.start（）
  * 推荐使用：避免单继承局限性，灵活方便，方便同一个对象被多个线程使用

### 实现Callable接口 *（了解）
1. 实现Callable接口，需要返回值类型 
2. 重写call方法，需要抛出异常 
3. 创建目标对象 
4. 创建执行服务:ExecutorService ser = Executors.newFixedThreadPool(1); 
5. 提交执行:Future<Boolean> result1 = ser.submit(t1); 
6. 获取结果:boolean r1 = result1.get()
7. 关闭服务: ser.shutdownNow();

### 网图下载
例子：
-> downloadByThread.java  <-
-> downloadByRunnable.java  <-
-> downloadByCallableThread.java  <-

## 线程状态
![线程状态](https://img-blog.csdnimg.cn/0c113d6a170f40ff8fe26cf6e4042f0a.png)
* 新建状态（new）：Thread t = new Thread(); 创建一个线程对象后，该线程对象就处新建状态。此时它不能运行，和其他Java对象一样，仅仅由Java虚报机为其分配了内存，没有表现出任何线程的动态特征，
* 就绪状态(Runnable)：当线程对象调用了start （）后，该线程就进人就绪状态，也称可运行状态。处于就绪状态的线程放人到可运行池中，此时它只是其就进运行的条件，能否获得CPU的使用权，正需要等待系统的调度。
* 运行状态(Running)：如果处于就绪状态的线程获得了 CPU的使用权，开始执行run()方法，则该线程处于运行状态。当一个线程启动后，它不可能一直处于运行状态，当使用完系统分配CPU使用权时同后，系统就会剥夺该线程占有的CPU资源，让其他线程获得执行的机会。
* 阻塞状态(Blocked):一个正在执行的线程在某些特殊情况下，如执行耗时的输入/输出操作时，会放弃CPU的使用权，进人阻塞状态。线程进人阻塞状态后，就不能进人排队队列。只有当引起阻塞的原因被消除后，线程才可以转人就绪状态。常见的线程状态转换成阻塞状态的原因，以及如何从阻塞状态转换成就绪状态。
  * 当线程试图获取某个对象的同步锁时，如果该锁被其他线程所持有，则当前线程会进人阻塞状态。如果想从阻塞状态进人就绪状态必须得获取到其他线程所持有的锁。
  * 当线程调用了一个阻塞式的IO方法时，该线程就会进人阻塞状态，如果想进人就绪状态就必须要等到这个阻塞的IO方法返回。
  * 当线程调用了某个对象的wait ( )方法时，也会使线程进人阻塞状态，如果想进入就绪状态就需要使用notify ( )方法唤醒该线程。
  * 当线程调用了Thread的sleep (long millis)方法时，也会使线程进人阻塞状态，在这种情况下，只需等到线程睡眠的时间到了以后，线程就会自动进人就绪状态，
  * 当在一个线程中调用了另 一个线程的join ()方法时，会使当前线程进人阻塞状态，在这种情况下，需要等到新加人的线程运行结束后才会结束阻塞状态，进入就绪状态。
  * 需要注意的是，线程从阻塞状态只能进入就绪状态，而不能直接进人运行状态，也就是说结束阻塞的线程需要重新进人可运行池中，等待系统的调度
* 死亡状态(Terminated)：线程的run（）方法正常执行完毕或者线程抛出一个未捕获的异常或者错误时，线程就进人死亡状态。一旦进人死亡状态，线程将不再拥有运行的资格，也不能再转化到其他状态。

例子：
-> ThreadState.java  <-

### 停止线程
* 不推荐使用JDK提供的stop()、destroy()方法。【已废弃】
* 推荐线程自己停止下来
* 建议使用一个标志位进行终止变量当flag=false，则终止线程运行。

例子：
-> TestStop.java  <-

### 线程的调度
线程调度指按照特定机制为多个线程分配CPU的使用权。

|             线程方法             |                                            |
| :------------------------------: | :----------------------------------------: |
|               方法               |                    说明                    |
|  setPriority（int newPriority）  |              更改线程的优先级              |
| static void sleep（long millis） |  在指定的毫秒数内让当前正在执行的线程休眠  |
|          void join（）           |               等待该线程终止               |
|       static void yield()        | 暂停当前正在执行的线程对象，并执行其他线程 |
|         void interrupt()         |           中断线程，别用这个方式           |
|        boolean isAlive()         |          测试线程是否处于活动状态          |
### 线程的优先级
* Java提供一个线程调度器来监控程序中启动后进入就绪状态的所有线程，线程调度器按照优先级决定应该调度哪个线程来执行。
* 优先级越高的线程获得CPU执行的机会越大。 
* 优先级越低的线程获得CPU执行的机会越小。 
* 线程的优先级用数字表示，范围从1~10
  * Thread.MIN_PRIORITY= 1;
  * Thread.MAX_PRIORITY = 10;
  * Thread.NORM_PRIORITY = 5;
* 使用以下方式改变或获取优先级
  * getPriority() || setPriority(int xxx)

例子：
-> Priority.java  <-

### 线程休眠
* 让线程暂时睡眠指定时长,线程进入阻塞状态。 
* 睡眠时间过后线程会再进入可运行状态。 
* sleep (时间)指定当前线程阻塞的毫秒数。 
* sleep存在异常InterruptedException。 
* sleep时间达到后线程进入就绪状态。 
* sleep可以模拟网络延时，倒计时等。 
* 每一个对象都有一个锁，sleep不会释放锁。

例子：
-> Sleep.java  <-

### 线程让步
* 礼让线程，让当前正在执行的线程暂停，但不阻塞。
* 将线程从运行状态转为就绪状态。
* 让cpu重新调度，礼让不一定成功!看CPU心情。

例子：
-> ThreadYield.java  <-

### 线程插队
* 也叫线程的强制执行。
* 使当前线程暂停执行，等待其他线程结束后再继续执行本线程
  * public final void join()
  * public final void join(long mills)
  * public final void join(long mills,int nanos)
  * millis:以毫秒为单位的等待时长
  * nanos:要等待的附加纳秒时长
  * 需处理InterruptedException异常

例子：
-> ThreadJoin.java  <-

### 线程状态观测
Thread.State
线程状态。线程可以处于以下状态之一：
  * NEW：尚未启动的线程处于此状态。
  * RUNNABLE：在Java虚拟机中执行的线程处于此状态。
  * BLOCKED：被阻塞等待监视器锁定的线程处于此状态。·
  * WAITING：正在等待另一个线程执行特定动作的线程处于此状态。
  * TIMED_WAITING：正在等待另一个线程执行动作达到指定等待时间的线程处于此状态。
  * TERMINATED：已退出的线程处于此状态。
一个线程可以在给定时间点处于一个状态。这些状态是不反映任何操作系统线程状态的虚拟机状态。


例子：
-> TestState.java  <-


### 守护线程（daemon）
* 线程分为用户线程和守护线程
* 虚拟机必须确保用户线程执行完毕
* 虚拟机不用等待守护线程执行完毕 如：
  * 后台记录操作日志
  * 监控内存
  * 垃圾回收等待

例子：
-> TestDaemon.java  <-

## 多线程同步
* 多线程的并发执行虽然可以提高程序的效率，但是，当多个线程去访问同一个资源时，也会引发一些安全问题。
* 并发：同一个对象被多个线程同时操作。
* 处理多线程问题时,多个线程访问同一个对象﹐并且某些线程还想修改这个对象﹒这时候我们就需要线程同步.线程同步其实就是一种等待机制,多个需要同时访问此对象的线程进入这个对象的等待池形成队列,等待前面线程使用完毕，下一个线程再使用

* 由于同一进程的多个线程共享同一块存储空间﹐在带来方便的同时,也带来了访问冲突问题﹐为了保证数据在方法中被访问时的正确性,在访问时加入锁机制synchronized,当一个线程获得对象的排它锁,独占资源﹐其他线程必须等待，使用后释放锁即可.存在以下问题：
  * 一个线程持有锁会导致其他所有需要此锁的线程挂起;
  * 在多线程竞争下,加锁，释放锁会导致比较多的上下文切换和调度延时,引起性能问题;
  * 如果一个优先级高的线程等待一个优先级低的线程释放锁会导致优先级倒置，引起性能问题．

我们可以通过private关键字来保证数据对象只能被方法访问﹐所以我们只需要针对方法提出一套机制,这套机制就是synchronized关键字，目前多线程同步有常用的两种方法，分别是同步代码块和同步方法。

### 同步代码块
当多个线程使用同一个资源时，可以将处理共享资源的代码放置在一个代码块中，使用synchronized关键字来修饰，被称作同步代码块
格式如下：
```
synchronized(lock){
    //操作共享资源代码块
}
```
上述代码中，lock 是一个锁对象称之为同步监视器，它是同步代码块的关键。当线程执行同步代码块时，首先会检查锁对象的标志位，默认情况下标志位为1,此时线程会执行同步代码块，同时将锁对象的标志位置为0。当一个新的线程执行到这段同步代码块时，由于锁对象的标志位为0,新线程会发生阻塞，等待当前线程执行完同步代码块后，锁对象的标志位被置为1，新线程才能进人同步代码块执行其中的代码。循环往复，直到共享资源被处理完为止
### 同步方法
在方法前面同样可以使用synchronized关键字来修饰，被修饰的方法为同步方法，它能实现和同步代码块同样的功能。具体语法格式如下:
```
public synchronized void method(int args){

}
```
synchronized方法控制对“对象”的访问，被synchronized修饰的方法在某一时刻只允许一个线程访问，访问该方法的其他线程都会发生阻塞，直到当前线程访问完毕后，其他线程才有机会执行方法。

缺陷：若将一个大的方法申明为synchronized将会影响效率。

### 死锁
多个线程各自占有一些共享资源﹐并且互相等待其他线程占有的资源才能运行﹐而导致两个或者多个线程都在等待对方释放资源﹐都停止执行的情形．某一个同步块同时拥有“两个以上对象的锁”时,就可能会发生“死锁”的问题。

例子：
-> TestLock.java  <-

产生死锁的四个必要条件:
1. 互斥条件:一个资源每次只能被一个进程使用。
2. 请求与保持条件:一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。
上面列出了死锁的四个必要条件，我们只要想办法破其中的任意一个或多个条件就可以避免死锁发生。

## 多线程通信

| 多线程通信常用方法 |                                                              |
| :----------------- | :----------------------------------------------------------- |
| 方法名称           | 功能描述                                                     |
| void wait()        | 使当前线程放弃同步锁并进入等待，直到其他线程进人此同步锁，调用notify ( )方法，或notifyAll ()方法唤醒该线程为止 |
| vold notify ( )    | 唤醒此同步锁上等待的第-一个调用wait () 方法的线程            |
| void notifyAll ()  | 唤醒此同步锁上调用wait()方法的所有线程                       |

例子：
-> ProduceDemo.java  <-

## 线程池
* 背景:经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。
* 思路:提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。
* 好处:
  * 提高响应速度（减少了创建新线程的时间)
  * 降低资源消耗（重复利用线程池中线程，不需要每次都创建)
  * 便于线程管理(....)
    * corePoolSize:核心池的大小maximumPoolSize:最大线程数
    * keepAliveTime:线程没有任务时最多保持多长时间后会终止
* JDK 5.0起提供了线程池相关API: ExecutorService和Executors
* ExecutorService:真正的线程池接口。常见子类ThreadPoolExecutor
  * void execute(Runnable command)∶执行任务/命令，没有返回值，一般用来执行Runnable
  * <T> Future<T> submit(Callable<T> task):执行任务，有返回值，一般又来执行Callable
  * void shutdown()∶关闭连接池
* Executors:工具类、线程池的工厂类，用于创建并返回不同类型的线程池

例子：
-> TestPool.java  <-


[参考资料](https://blog.csdn.net/m0_52896041/article/details/127466234?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-127466234-blog-126199787.pc_relevant_3mothn_strategy_and_data_recovery&spm=1001.2101.3001.4242.1&utm_relevant_index=3)
